这堂课可以清晰地分为两个核心部分：
1.  **定点数 (Fixed-point Numbers):** 如何表示整数，特别是如何解决**负数**的表示问题。
2.  **浮点数 (Floating-point Numbers):** 如何像“科学计数法”一样，表示小数、极大或极小的数。

---

### Part 1: 定点数 (Fixed-point Numbers) - 表示整数

“定点”的意思是，我们默认小数点的位置是固定的（通常在所有数字的末尾），所以我们主要讨论的是整数。

#### 1. 无符号整数 (Unsigned Binary) (Slide 6)

这是最简单的形式，就是我们熟悉的二进制计数。所有位都用来表示数值。
*   **规则：** 直接将二进制转换为十进制。
*   **范围：** 对于一个 N 位的二进制数，它可以表示的范围是 `[0, 2^N - 1]`。
    *   例如，一个4位数，可以表示从 `0000` (0) 到 `1111` (15) 的16个数字。
*   **问题：** 它**无法表示负数**。

#### 2. 带符号整数 (Signed Integers) - 负数的表示方法

为了表示负数，我们必须牺牲一位来记录符号信息。通常，我们用**最高有效位 (Most Significant Bit, MSB)**，也就是最左边的一位，作为**符号位**。
*   **0** 代表 **正数**
*   **1** 代表 **负数**

课程介绍了三种主流的表示方案，前两种有缺陷，第三种是现代计算机的通用标准。

##### 方案一：原码 (Signed-magnitude) (Slides 9-10)

*   **思路：** 这是最符合人类直觉的方法。符号位管符号，剩下的位管数值大小。
    *   `+5` (0101) -> `0`代表正，`101`是5。
    *   `-5` (1101) -> `1`代表负，`101`是5。
*   **致命缺陷：**
    1.  **有两个“零”：** `+0` (0000) 和 `-0` (1000)。这在数学上是冗余的，在硬件设计上是灾难。
    2.  **算术运算极其复杂：** 计算机不能简单地把它们当二进制数相加。比如计算 `4 + (-3)`，你不能直接算 `0100 + 1011`。硬件需要先判断符号，再比较大小，最后决定做加法还是减法，非常麻烦。

##### 方案二：反码 (One's Complement) (Slides 11-14)

*   **思路：** 试图解决原码的运算问题。
    *   **正数：** 和原码一样。`+7` 是 `0111`。
    *   **负数：** 将其对应正数的**所有位按位取反** (0变1，1变0)。
        *   `-7` 的求法：先找到 `+7` (`0111`)，然后每一位都取反，得到 `1000`。
*   **优点：** 解决了大部分算术问题。减法可以转换为加法。如 `4 - 3` 可以变成 `4 + (-3)`，即 `0100 + 1100 = 1 0000`。当产生最高位进位时，需要把它加回到结果的末尾（称为**“循环进位”**），`0000 + 1 = 0001`，结果为1。**正确！**
*   **致命缺陷：** 依然**有两个“零”！** `+0` (0000) 和 `-0` (1111)。这个问题还是没解决。

##### 方案三：补码 (Two's Complement) - 现代计算机的选择！(Slides 15-17)

*   **思路：** 这是反码的优化版，完美解决了所有问题。
    *   **正数：** 和原码、反码都一样。`+7` 是 `0111`。
    *   **负数：** 求其反码，然后**在末尾加1**。
        *   `-7` 的求法：`+7` (`0111`) -> 反码 (`1000`) -> 加1 -> `1001`。
*   **巨大优势：**
    1.  **只有一个“零”：** `0000` 代表0。`1111` 在这个体系里代表-1。再也没有 `-0` 的问题了。
    2.  **算术运算极度简化：** 减法可以完全等价于加法，硬件不需要任何额外的判断逻辑。直接按二进制位相加，**如果最高位有进位，直接丢弃即可**。
        *   `4 - 3` -> `4 + (-3)` -> `0100 + 1101 = 1 0001`。丢掉最前面的进位 `1`，结果是 `0001`，就是1。**完美！**
*   **范围：** 对于N位数，范围是 `[-2^(N-1), 2^(N-1) - 1]`。比原码和反码能多表示一个负数。例如4位数，范围是 `[-8, 7]`。

#### 3. 补码的实际问题：溢出 (Overflow) 和符号扩展 (Sign Extension)

*   **溢出 (Overflow) (Slides 20-29):**
    *   **问题：** 当运算结果超出了N位补码所能表示的范围时，就会发生溢出。就像一个4位的里程表，最大是9999，再加1就“溢出”变回0000了。
    *   **例子 (Slide 20)：** `3 + 7 = 10`。但在4位补码中，`0011 + 0111 = 1010`。`1010`在补码里代表 **-6**！这就是溢出，一个正数加正数得到了负数。
    *   **检测规则 (Slide 29)：** 溢出只在**同号数相加**时才可能发生。最简单的检测方法是：**如果进入符号位的进位 (carry-in to MSB) 和从符号位出去的进位 (carry-out from MSB) 不相等，则发生了溢出。**

*   **符号扩展 (Sign Extension) (Slides 30-34):**
    *   **问题：** 当不同位数的补码进行运算时（比如一个4位数和一个8位数相加），必须先把位数少的那个数扩展成相同的位数。
    *   **规则：** 非常简单，就是**用符号位去填充新增加的高位**。
        *   **正数** (符号位为0): 用 `0` 填充。`0101` (5) -> `0000 0101` (还是5)。
        *   **负数** (符号位为1): 用 `1` 填充。`1011` (-5) -> `1111 1011` (还是-5)。
    *   **作用：** 符号扩展可以确保在扩展位数后，**数字的符号和值都保持不变**。

---

### Part 2: 浮点数 (Floating-point Numbers) - 表示科学计数法

当我们需要表示 `3.14` 或者 `6.02 x 10^23` 这样的数时，定点数就无能为力了。这时我们需要浮点数。

*   **核心思想 (Slide 36)：** 模拟科学计数法 `A = P × Q^D`。
    *   `P` 是 **尾数 (Mantissa)**：表示数字的精度。
    *   `Q` 是 **基数 (Base)**：在计算机里总是2。
    *   `D` 是 **指数 (Exponent)**：表示小数点要移动多少位。

*   **IEEE 754 标准 (Slides 40-43)：** 这是全球通用的浮点数表示标准，它规定了如何用一串二进制位来存储一个浮点数。以32位单精度浮点数为例：
    *   **1位 符号位 (Sign bit):** 0为正，1为负。
    *   **8位 指数位 (Exponent):** 用来存储指数。它采用了一种叫**“偏置表示法”**的方法，即将真实指数加上一个固定的偏移量（对于8位是127）来存储，这样就可以不用符号位来表示正负指数。
    *   **23位 尾数位 (Mantissa):** 用来存储数值的精度。它有一个巧妙的优化：对于规格化的二进制数，第一位永远是1（比如 `1.xxxx`），所以这个 `1` **不需要被存储**，从而凭空多出一位精度。

*   **定点 vs. 浮点 (Slides 45-46):**
    *   **定点数：** 表示范围有限，但运算电路**简单、快速、低功耗**。适用于对性能和功耗要求苛刻，且数值范围可预知的场景（如很多嵌入式系统）。
    *   **浮点数：** 表示范围极大，但运算电路**复杂、缓慢、高功耗**。适用于需要进行科学计算、图形处理等通用计算场景。

### 总结

这节课的核心是教会你计算机是如何用二进制来编码数字的：
1.  对于**整数**，**补码 (Two's Complement)** 是王者，因为它解决了负数运算和零的唯一性问题。但使用时要注意**溢出**和**符号扩展**。
2.  对于**小数和科学计数**，**浮点数 (Floating-point)** 是标准，它通过 **IEEE 754** 规范，将一个数拆分为**符号、指数、尾数**三部分来存储，从而获得了巨大的表示范围。
3.  你需要根据应用场景在**定点数（快、省、范围小）**和**浮点数（慢、贵、范围大）**之间做出权衡。